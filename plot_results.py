"""
Plotting script for Harvest Timing Model.

Loads results from pickle file generated by harvest_timing_model.py and generates plots.
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
import pickle
import argparse
from typing import Dict, Tuple, Optional

# Import definitions from main model
from harvest_timing_model import (
    ModelParameters, 
    StateSpace, 
    simulate_price_paths,
    simulate_single_trajectory,
    compute_carbon_curve,
    compute_volume_from_carbon,
    compute_carbon_flows_averaging,
    compute_carbon_flows_permanent,
    compute_price_quality_factor,
    build_reward_matrix,
    build_transition_matrix,
    ACTION_DO_NOTHING,
    ACTION_HARVEST_REPLANT,
    ACTION_SWITCH_PERMANENT
)

def plot_price_paths(
    params: ModelParameters,
    n_paths: int = 1000,
    n_periods: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot simulated price paths for carbon and timber prices.
    
    Shows the stochastic nature of the AR(1) price processes.
    """
    # Simulate paths
    carbon_paths = simulate_price_paths(
        params.pc_mean, params.pc_rho, params.pc_sigma,
        n_paths=n_paths, n_periods=n_periods, seed=42, p0=params.pc_0
    )
    timber_paths = simulate_price_paths(
        params.pt_mean, params.pt_rho, params.pt_sigma,
        n_paths=n_paths, n_periods=n_periods, seed=123
    )
    
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    years = np.arange(n_periods)
    
    # --- Carbon price paths ---
    ax = axes[0]
    
    # Plot individual paths with transparency
    for i in range(n_paths):
        ax.plot(years, carbon_paths[i, :], color='#3498db', alpha=0.03, linewidth=0.5)
    
    # Plot percentiles
    p5 = np.percentile(carbon_paths, 5, axis=0)
    p25 = np.percentile(carbon_paths, 25, axis=0)
    # p50 = np.percentile(carbon_paths, 50, axis=0)
    p75 = np.percentile(carbon_paths, 75, axis=0)
    p95 = np.percentile(carbon_paths, 95, axis=0)
    
    ax.fill_between(years, p5, p95, alpha=0.2, color='#3498db', label='5th-95th percentile')
    ax.fill_between(years, p25, p75, alpha=0.3, color='#3498db', label='25th-75th percentile')
    # ax.plot(years, p50, color='#2c3e50', linewidth=2, label='Median')
    ax.axhline(params.pc_mean, color='#e74c3c', linestyle='--', linewidth=1.5, label=f'Mean = ${params.pc_mean:.0f}')
    
    ax.set_xlabel('Year', fontsize=14)
    ax.set_ylabel('Carbon price ($/tCO₂)', fontsize=14)
    ax.set_title(f'Sampled carbon price trajectories (n={n_paths})', 
                 fontsize=16, fontweight='bold')
    ax.legend(loc='upper right', fontsize=12)
    ax.tick_params(axis='both', labelsize=12)
    ax.set_xlim(0, n_periods - 1)
    ax.set_ylim(0, 300)
    ax.grid(True, alpha=0.3)
    
    # --- Timber price paths ---
    ax = axes[1]
    
    # Plot individual paths with transparency
    for i in range(n_paths):
        ax.plot(years, timber_paths[i, :], color='#27ae60', alpha=0.03, linewidth=0.5)
    
    # Plot percentiles
    p5 = np.percentile(timber_paths, 5, axis=0)
    p25 = np.percentile(timber_paths, 25, axis=0)
    # p50 = np.percentile(timber_paths, 50, axis=0)
    p75 = np.percentile(timber_paths, 75, axis=0)
    p95 = np.percentile(timber_paths, 95, axis=0)
    
    ax.fill_between(years, p5, p95, alpha=0.2, color='#27ae60', label='5th-95th percentile')
    ax.fill_between(years, p25, p75, alpha=0.3, color='#27ae60', label='25th-75th percentile')
    # ax.plot(years, p50, color='#2c3e50', linewidth=2, label='Median')
    ax.axhline(params.pt_mean, color='#e74c3c', linestyle='--', linewidth=1.5, label=f'Mean = ${params.pt_mean:.0f}')
    
    ax.set_xlabel('Year', fontsize=14)
    ax.set_ylabel('Timber price ($/m³)', fontsize=14)
    ax.set_title(f'Sampled timber price trajectories (n={n_paths})', 
                 fontsize=16, fontweight='bold')
    ax.legend(loc='upper right', fontsize=12)
    ax.tick_params(axis='both', labelsize=12)
    ax.set_xlim(0, n_periods - 1)
    ax.set_ylim(0, 300)
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Price paths plot saved to: {save_path}")
    
    # Second figure: just 5 individual paths, no labels, different colors
    fig2, axes2 = plt.subplots(1, 2, figsize=(14, 5))
    
    # Define distinct colors for the 5 paths
    colors = ['#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c']
    
    # --- Carbon price paths (5 lines) ---
    ax2 = axes2[0]
    for i in range(5):
        ax2.plot(years, carbon_paths[i, :], color=colors[i], alpha=0.8, linewidth=1.5)
    
    ax2.set_xlabel('Year', fontsize=14)
    ax2.set_ylabel('Carbon price ($/tCO₂)', fontsize=14)
    ax2.set_title('Sampled carbon price pathways (5 samples)', 
                 fontsize=16, fontweight='bold')
    ax2.tick_params(axis='both', labelsize=12)
    ax2.set_xlim(0, n_periods - 1)
    ax2.set_ylim(0, None)
    ax2.grid(True, alpha=0.3)
    
    # --- Timber price paths (5 lines) ---
    ax2 = axes2[1]
    for i in range(5):
        ax2.plot(years, timber_paths[i, :], color=colors[i], alpha=0.8, linewidth=1.5)
    
    ax2.set_xlabel('Year', fontsize=14)
    ax2.set_ylabel('Timber price ($/m³)', fontsize=14)
    ax2.set_title('Sampled timber price pathways (5 samples)', 
                 fontsize=16, fontweight='bold')
    ax2.tick_params(axis='both', labelsize=12)
    ax2.set_xlim(0, n_periods - 1)
    ax2.set_ylim(0, None)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Save to plots directory if provided, or construct name
    if save_path:
        # Assuming save_path is something like 'plots/price_paths.png'
        # We want 'plots/price_paths_10_samples.png'
        dir_name = os.path.dirname(save_path)
        base_name = os.path.basename(save_path)
        name_part = os.path.splitext(base_name)[0]
        ext_part = os.path.splitext(base_name)[1]
        
        sample_path = os.path.join(dir_name, f"{name_part}_10_samples{ext_part}")
        plt.savefig(sample_path, dpi=150, bbox_inches='tight')


def plot_decisions_by_price_state(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    ages: Tuple[int, int, int, int] = (10, 16, 25, 35),
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (timber price, carbon price) space
    for a specific regime/rotation at 4 different ages.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    for ax_idx, age in enumerate(ages):
        ax = axes.flatten()[ax_idx]
        
        # Clamp age to valid range
        a = min(age, params.N_a - 1)
        
        # Build decision matrix (timber price x carbon price)
        decision_matrix = np.zeros((params.N_pt, params.N_pc))
        
        for i_pt in range(params.N_pt):
            for i_pc in range(params.N_pc):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[i_pt, i_pc] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[pt_grid[0], pt_grid[-1], pc_grid[0], pc_grid[-1]]
        )
        
        ax.set_xlabel('Timber price ($/m³)', fontsize=11)
        ax.set_ylabel('Carbon price ($/tCO₂)', fontsize=11)
        ax.set_title(f'Age {age}', fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal decisions by price state\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def plot_decisions_timber_vs_age(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (age, timber price) space
    at 4 different carbon price levels.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    # Select 4 carbon price indices: very low, medium-low, medium-high, very high
    n_pc = params.N_pc
    pc_indices = [0, n_pc // 3, 2 * n_pc // 3, n_pc - 1]
    pc_labels = ['Very low', 'Medium-low', 'Medium-high', 'Very high']
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for ax_idx, (i_pc, pc_label) in enumerate(zip(pc_indices, pc_labels)):
        ax = axes.flatten()[ax_idx]
        
        # Build decision matrix (age x timber price)
        decision_matrix = np.zeros((plot_ages, params.N_pt))
        
        for a in range(plot_ages):
            for i_pt in range(params.N_pt):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[a, i_pt] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[0, plot_ages - 1, pt_grid[0], pt_grid[-1]]
        )
        
        ax.set_xlabel('Stand age (years)', fontsize=11)
        ax.set_ylabel('Timber price ($/m³)', fontsize=11)
        ax.set_title(f'{pc_label} carbon price (${pc_grid[i_pc]:.0f}/tCO₂)', 
                     fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal decisions: timber price vs age\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def plot_decisions_carbon_vs_age(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (age, carbon price) space
    at 4 different timber price levels.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    # Select 4 timber price indices: very low, medium-low, medium-high, very high
    n_pt = params.N_pt
    pt_indices = [0, n_pt // 3, 2 * n_pt // 3, n_pt - 1]
    pt_labels = ['Very low', 'Medium-low', 'Medium-high', 'Very high']
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for ax_idx, (i_pt, pt_label) in enumerate(zip(pt_indices, pt_labels)):
        ax = axes.flatten()[ax_idx]
        
        # Build decision matrix (age x carbon price)
        decision_matrix = np.zeros((plot_ages, params.N_pc))
        
        for a in range(plot_ages):
            for i_pc in range(params.N_pc):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[a, i_pc] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[0, plot_ages - 1, pc_grid[0], pc_grid[-1]]
        )
        
        ax.set_xlabel('Stand age (years)', fontsize=11)
        ax.set_ylabel('Carbon price ($/tCO₂)', fontsize=11)
        ax.set_title(f'{pt_label} timber price (${pt_grid[i_pt]:.0f}/m³)', 
                     fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal decisions: carbon price vs age\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def generate_all_decision_plots(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    max_age_plot: int = 50,
    output_dir: str = 'plots'
):
    """
    Generate all 9 decision region plots (3 states × 3 plot types).
    """
    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)
    
    # Define the 3 states to plot
    states = [
        (0, 1, 'averaging_1st', 'Averaging 1st Rotation'),
        (0, 2, 'averaging_2plus', 'Averaging 2+ Rotation'),
        (1, 1, 'permanent', 'Permanent'),  # rotation doesn't matter for permanent
    ]
    
    for regime, rotation, file_prefix, state_label in states:
        print(f"\n  Generating plots for {state_label}...")
        
        # 1. Price vs price at ages 10, 16, 25, 35
        plot_decisions_by_price_state(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            ages=(10, 16, 25, 35),
            save_path=os.path.join(output_dir, f'{file_prefix}_price_vs_price.png')
        )
        
        # 2. Timber price vs age at fixed carbon prices
        plot_decisions_timber_vs_age(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            max_age_plot=max_age_plot,
            save_path=os.path.join(output_dir, f'{file_prefix}_timber_vs_age.png')
        )
        
        # 3. Carbon price vs age at fixed timber prices
        plot_decisions_carbon_vs_age(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            max_age_plot=max_age_plot,
            save_path=os.path.join(output_dir, f'{file_prefix}_carbon_vs_age.png')
        )


def plot_simulation_trajectory(
    data: Dict,
    params: ModelParameters,
    save_path: str = 'plots/simulation_trajectory.png'
):
    """
    Plot the simulated trajectory (4 panels).
    """
    years = data['years']
    n_years = len(years)
    
    fig, axes = plt.subplots(4, 1, figsize=(12, 16), sharex=True)
    
    # --- Panel 1: Price Trajectories ---
    ax = axes[0]
    ax.plot(years, data['carbon_price'], color='#3498db', linewidth=2, label='Carbon Price ($/tCO₂)')
    ax.plot(years, data['timber_price'], color='#27ae60', linewidth=2, label='Timber Price ($/m³)')
    ax.set_ylabel('Price', fontsize=12)
    ax.set_title('Simulated price trajectories', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3)
    
    # --- Panel 2: Utilities (Q-values) ---
    ax = axes[1]
    ax.plot(years, data['q_hold'], color='#95a5a6', linestyle='-', linewidth=1.5, label='Hold Value')
    ax.plot(years, data['q_harvest'], color='#e74c3c', linestyle='--', linewidth=1.5, label='Harvest Value')
    ax.plot(years, data['q_switch'], color='#8e44ad', linestyle=':', linewidth=1.5, label='Switch Value')
    
    # Annotate actions
    # Plot markers where action is NOT Hold
    harvest_indices = np.where(data['action'] == ACTION_HARVEST_REPLANT)[0]
    switch_indices = np.where(data['action'] == ACTION_SWITCH_PERMANENT)[0]
    
    if len(harvest_indices) > 0:
        ax.scatter(years[harvest_indices], data['q_harvest'][harvest_indices], 
                   color='red', s=100, zorder=10, label='Harvest Action')
        for idx in harvest_indices:
            ax.annotate('Harvest', (years[idx], data['q_harvest'][idx]), 
                        xytext=(0, 15), textcoords='offset points', ha='center', color='red', fontweight='bold')
            
    if len(switch_indices) > 0:
        # Only mark the *first* switch if multiple (since switch is permanent state change)
        # But technically action 2 can be chosen repeatedly (though effect is idempotent)
        # We'll mark all just in case
        ax.scatter(years[switch_indices], data['q_switch'][switch_indices], 
                   color='purple', s=100, zorder=10, marker='s', label='Switch Action')
        for idx in switch_indices:
            # only annotate if it's a regime change
            if idx > 0 and data['regime'][idx] == 1 and data['regime'][idx-1] == 0:
                 ax.annotate('Switch', (years[idx], data['q_switch'][idx]), 
                            xytext=(0, 15), textcoords='offset points', ha='center', color='purple', fontweight='bold')
    
    ax.set_ylabel('Total utility ($/ha)', fontsize=12)
    ax.set_title('Option utilities (immediate + continuation)', fontsize=14, fontweight='bold')
    ax.legend(loc='upper left')
    ax.grid(True, alpha=0.3)
    
    # --- Panel 3: Net Revenue ---
    ax = axes[2]
    # Plot as bar chart? Or line with markers?
    # Most years are small negative (maintenance cost) or positive (carbon credits)
    # Harvest years are huge positive spikes.
    # Switch year might be negative spike (penalty).
    
    # Separate positive and negative for color
    pos_mask = data['net_revenue'] >= 0
    neg_mask = data['net_revenue'] < 0
    
    ax.bar(years[pos_mask], data['net_revenue'][pos_mask], color='#2ecc71', alpha=0.7, label='Net Revenue (>0)')
    ax.bar(years[neg_mask], data['net_revenue'][neg_mask], color='#e74c3c', alpha=0.7, label='Net Revenue (<0)')
    
    ax.axhline(0, color='black', linewidth=0.5)
    ax.set_ylabel('Net revenue ($/ha)', fontsize=12)
    ax.set_title('Realized net revenue', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3, axis='y')
    
    # --- Panel 4: Carbon Stock ---
    ax = axes[3]
    
    # Plot carbon stock
    # Color differently based on regime
    regime_0_mask = data['regime'] == 0
    regime_1_mask = data['regime'] == 1
    regime_2_mask = data['regime'] == 2
    
    # We can't easily use mask for line plot connectivity. 
    # Just plot entire line, then overlay?
    ax.plot(years, data['carbon_stock'], color='black', linewidth=1, alpha=0.3)
    
    # Plot segments
    # Simple way: scatter points
    ax.scatter(years[regime_0_mask], data['carbon_stock'][regime_0_mask], 
               color='#3498db', s=20, label='Averaging Regime')
    ax.scatter(years[regime_1_mask], data['carbon_stock'][regime_1_mask], 
               color='#e67e22', s=20, label='Permanent Regime')
    ax.scatter(years[regime_2_mask], data['carbon_stock'][regime_2_mask], 
               color='#8e44ad', s=20, label='Stock-change Regime')

    ax.set_ylabel('Carbon stock (tCO₂/ha)', fontsize=12)
    ax.set_title('Forest carbon stock', fontsize=14, fontweight='bold')
    ax.set_xlabel('Simulation year', fontsize=12)
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"\nTrajectory simulation saved to: {save_path}")
    

def plot_trajectory_conference(
    data: Dict,
    params: ModelParameters,
    regime_label: str,
    save_path: str = 'plots/trajectory_conference.png'
):
    """
    Conference-friendly 2-panel figure (landscape orientation):
    - Top panel: Price trajectories (carbon + timber)
    - Bottom panel: Immediate + continuation utility with harvest actions annotated
    
    Designed for big-screen presentation on landscape slides.
    """
    years = data['years']
    
    # Create figure with 2 rows, landscape orientation
    fig, axes = plt.subplots(2, 1, figsize=(14, 8), sharex=True,
                              gridspec_kw={'height_ratios': [1, 1.2], 'hspace': 0.15})
    
    # ============ Top Panel: Price Trajectories ============
    ax = axes[0]
    
    ax.plot(years, data['carbon_price'], color='#3498db', linewidth=2.5, 
            label='Carbon Price ($/tCO₂)')
    ax.plot(years, data['timber_price'], color='#27ae60', linewidth=2.5, 
            label='Timber Price ($/m³)')
    
    ax.set_ylabel('Price', fontsize=18)
    ax.set_title(f'Simulated price trajectories', fontsize=22, fontweight='bold', pad=10)
    ax.legend(loc='upper right', fontsize=16, framealpha=0.9)
    ax.grid(True, alpha=0.3, linewidth=0.5)
    ax.tick_params(axis='both', labelsize=14)
    
    # ============ Bottom Panel: Option Utilities ============
    ax = axes[1]
    
    # Plot utility lines
    ax.plot(years, data['q_hold'], color='#7f8c8d', linestyle='-', linewidth=2, 
            label='Hold (continue)', alpha=0.8)
    ax.plot(years, data['q_harvest'], color='#e74c3c', linestyle='--', linewidth=2, 
            label='Harvest & replant', alpha=0.8)
    
    # Find and annotate harvest actions
    harvest_indices = np.where(data['action'] == ACTION_HARVEST_REPLANT)[0]
    
    # Mark harvest actions with prominent markers and vertical lines
    if len(harvest_indices) > 0:
        for idx in harvest_indices:
            # Vertical line spanning the panel
            ax.axvline(x=years[idx], color='#e74c3c', linestyle='-', 
                      linewidth=1.5, alpha=0.4, zorder=1)
            # Marker at the harvest value
            ax.scatter(years[idx], data['q_harvest'][idx], 
                      color='#e74c3c', s=150, zorder=10, edgecolors='white', linewidth=2)
            # Annotation
            ax.annotate(f'Harvest\n(yr {years[idx]})', 
                       (years[idx], data['q_harvest'][idx]),
                       xytext=(8, -10), textcoords='offset points',
                       fontsize=14, fontweight='bold', color='#c0392b',
                       ha='left', va='top',
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='white', 
                                edgecolor='#e74c3c', alpha=0.9))
    
    ax.set_ylabel('Total utility ($/ha)', fontsize=18)
    ax.set_xlabel('Forest age', fontsize=18, fontweight='bold')
    ax.set_title(f'Option utilities: {regime_label}', fontsize=22, fontweight='bold', pad=10)
    ax.legend(loc='upper right', fontsize=16, framealpha=0.9)
    ax.grid(True, alpha=0.3, linewidth=0.5)
    ax.tick_params(axis='both', labelsize=14)
    
    # Ensure x-axis shows full range
    ax.set_xlim(years[0], years[-1])
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=200, bbox_inches='tight', facecolor='white')
        print(f"  Conference trajectory saved to: {save_path}")
    
    plt.close(fig)


def plot_trajectory_revenue_conference(
    data: Dict,
    params: ModelParameters,
    regime_label: str,
    save_path: str = 'plots/trajectory_revenue_conference.png'
):
    """
    Conference-friendly 2-panel figure (landscape orientation):
    - Top panel: Price trajectories
    - Bottom panel: Potential harvest revenue (Timber vs Carbon) over time
    
    The bottom panel shows what the net revenue of harvesting *would* be
    at each point in time, decomposed into timber and carbon components.
    """
    years = data['years']
    n_years = len(years)
    
    # 1. Calculate potential timber harvest and realized carbon revenue
    C_curve = compute_carbon_curve(params)
    V_age = compute_volume_from_carbon(C_curve, params)
    DeltaC_avg = compute_carbon_flows_averaging(C_curve, params)
    DeltaC_perm = compute_carbon_flows_permanent(C_curve)
    price_quality_factor = compute_price_quality_factor(params)
    liability_npv_factor = params.carbon_liability_npv_factor()
    
    potential_timber = np.zeros(n_years)
    realized_carbon = np.zeros(n_years)
    
    for t in range(n_years):
        age = data['age'][t]
        regime = data['regime'][t]
        rotation = data['rotation'][t]
        pc = data['carbon_price'][t]
        pt = data['timber_price'][t]
        action = data['action'][t]
        
        volume = V_age[age]
        carbon_stock = C_curve[age]
        
        # --- Potential Timber Revenue (if we were to harvest at t) ---
        harvest_cost_per_m3 = params.harvest_cost_per_m3
        if regime == 1: # Permanent
            harvest_cost_per_m3 += params.harvest_penalty_per_m3
            
        effective_pt = pt * price_quality_factor[age]
        R_timber = (effective_pt - harvest_cost_per_m3) * volume - params.replant_cost - params.harvest_cost_flat_per_ha
        potential_timber[t] = R_timber
        
        # --- Realized Net Carbon Revenue ---
        if action == ACTION_HARVEST_REPLANT:
            # Carbon liability on harvest (realized loss)
            if regime >= 1: # Permanent or Stock-change
                realized_carbon[t] = -pc * carbon_stock * liability_npv_factor
            else:
                realized_carbon[t] = 0.0
        else:
            # Annual carbon credits (realized gain)
            if regime == 0: # Averaging
                delta_C = DeltaC_avg[age] if rotation == 1 else 0.0
            else: # Permanent or Stock-change
                delta_C = DeltaC_perm[age]
            realized_carbon[t] = pc * delta_C
            
    # Create figure
    fig, axes = plt.subplots(2, 1, figsize=(14, 8), sharex=True,
                              gridspec_kw={'height_ratios': [1, 1.2], 'hspace': 0.15})
    
    # ============ Top Panel: Price Trajectories ============
    ax0 = axes[0]
    ax0.plot(years, data['carbon_price'], color='#3498db', linewidth=2.5, label='Carbon Price ($/tCO₂)')
    ax0.plot(years, data['timber_price'], color='#27ae60', linewidth=2.5, label='Timber Price ($/m³)')
    ax0.set_ylabel('Price', fontsize=14, fontweight='bold')
    ax0.set_title(f'Simulated price trajectories', fontsize=16, fontweight='bold', pad=10)
    ax0.legend(loc='upper right', fontsize=12, framealpha=0.9)
    ax0.grid(True, alpha=0.3, linewidth=0.5)
    
    # ============ Bottom Panel: Net Revenue Components ============
    ax_rev = axes[1]
    
    # Identify actual harvest years
    harvest_mask = data['action'] == ACTION_HARVEST_REPLANT
    other_mask = ~harvest_mask
    
    # Bar widths and offsets to show them side-by-side
    width = 0.4
    
    # Plot Carbon - Realized Net Revenue
    pos_carbon = np.maximum(0, realized_carbon)
    neg_carbon = np.minimum(0, realized_carbon)
    
    ax_rev.bar(years - width/2, pos_carbon, width=width, color='#3498db', alpha=0.8, 
               label='Carbon Credits (Gain)')
    ax_rev.bar(years - width/2, neg_carbon, width=width, color='#e74c3c', alpha=0.8, 
               label='Carbon Liability (Loss)')
    
    # Plot Timber - Potential vs Realized
    # Faint bars for potential (what if we harvested)
    ax_rev.bar(years[other_mask] + width/2, potential_timber[other_mask], 
               width=width, color='#2ecc71', alpha=0.2, label='Potential Timber Profit')
    # Solid bars for realized harvest
    ax_rev.bar(years[harvest_mask] + width/2, potential_timber[harvest_mask], 
               width=width, color='#27ae60', alpha=1.0, label='Realized Timber Profit',
               edgecolor='black', linewidth=1)
    
    # Annotate harvest events
    harvest_indices = np.where(harvest_mask)[0]
    for idx in harvest_indices:
        total_rev = potential_timber[idx] + realized_carbon[idx]
        ax_rev.annotate(f'Harvest\nNet: ${total_rev/1000:.1f}k',
                        xy=(years[idx] + width/2, potential_timber[idx]),
                        xytext=(0, 20), textcoords='offset points',
                        ha='center', va='bottom', fontsize=10, fontweight='bold',
                        bbox=dict(boxstyle='round,pad=0.3', facecolor='white', edgecolor='black', alpha=0.8),
                        arrowprops=dict(arrowstyle='->', color='black'))

    # Styling
    ax_rev.set_ylabel('Net revenue ($/ha)', fontsize=14, fontweight='bold')
    ax_rev.tick_params(axis='y', labelsize=12)
    
    ax_rev.set_xlabel('Simulation year', fontsize=14, fontweight='bold')
    ax_rev.set_title(f'Net revenue components: {regime_label}', fontsize=16, fontweight='bold', pad=10)
    
    # Legends
    ax_rev.legend(loc='lower left', fontsize=10, framealpha=0.9, ncol=2)
    
    ax_rev.grid(True, alpha=0.2)
    ax_rev.axhline(0, color='black', linewidth=0.8, alpha=0.5)
    
    ax_rev.set_xlim(years[0] - 1, years[-1] + 1)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=200, bbox_inches='tight', facecolor='white')
        print(f"  Revenue trajectory saved to: {save_path}")
    
    plt.close(fig)


def plot_accounting_comparison(
    excel_path: str,
    params: ModelParameters,
    save_path: str = 'plots/accounting_comparison.png'
):
    """
    Replicate the accounting comparison figure using data from growth_curves.xlsx.
    Shows Stock Change, Averaging, and Permanent regimes with a harvest at age 28.
    """
    # 1. Load data
    try:
        df = pd.read_excel(excel_path, sheet_name='carbon table')
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return

    scion_col = 't CO2/ha (NI) - Scion report on revised carbon tables'
    if scion_col not in df.columns:
        print(f"Column '{scion_col}' not found in Excel. Available columns: {df.columns.tolist()}")
        return
        
    ages = df['Age'].values
    permanent_stock = df[scion_col].values
    
    # Limit to age 51
    max_plot_age = 51
    mask = ages <= max_plot_age
    ages = ages[mask]
    permanent_stock = permanent_stock[mask]
    
    # 2. Calculate Averaging
    # Follows permanent until age 16, then stays flat (NZ averaging level)
    avg_age_limit = 16
    averaging_stock = np.zeros(len(ages))
    avg_level = permanent_stock[avg_age_limit]
    for i, a in enumerate(ages):
        if a <= avg_age_limit:
            averaging_stock[i] = permanent_stock[i]
        else:
            averaging_stock[i] = avg_level
            
    # 3. Calculate Stock Change (with harvest at 28)
    harvest_age = 28
    stock_change = np.zeros(len(ages))
    
    # Liability parameters from model logic
    # On harvest: pay back accumulated stock (with instant fraction and spread over years)
    inst_frac = params.carbon_liability_instant_fraction
    liab_years = params.carbon_liability_years
    
    current_acc = 0.0
    annual_repayment = 0.0
    
    for i, a in enumerate(ages):
        if a == 0:
            current_acc = 0.0
        elif a <= harvest_age:
            # Normal growth credits
            delta = permanent_stock[i] - permanent_stock[i-1]
            current_acc += delta
            
            if a == harvest_age:
                # Harvest occurs
                liability = current_acc
                instant_pay = liability * inst_frac
                annual_repayment = (liability - instant_pay) / liab_years
                current_acc -= (instant_pay + annual_repayment)
        else:
            # Regrowth credits (starting from age 1)
            regrowth_age = a - harvest_age
            if regrowth_age < len(permanent_stock):
                delta_regrowth = permanent_stock[regrowth_age] - permanent_stock[regrowth_age-1]
                current_acc += delta_regrowth
            
            # Liability repayment over 10 years
            if regrowth_age < liab_years:
                current_acc -= annual_repayment
                
        stock_change[i] = current_acc

    # 4. Plotting
    fig, ax = plt.subplots(figsize=(12, 7))
    
    # Style matches plot_utility_histograms:
    # Averaging: Blue (#3498db)
    # Permanent: Orange (#e67e22)
    # Stock Change: Purple (#8e44ad)
    ax.plot(ages, averaging_stock, color='#3498db', linewidth=3, label='Averaging', zorder=4)
    ax.plot(ages, permanent_stock, color='#e67e22', linewidth=3, label='Permanent', zorder=2)
    ax.plot(ages, stock_change, color='#8e44ad', linewidth=3, label='Stock change', zorder=3)
    
    # Vertical line at assumed harvest
    ax.axvline(x=harvest_age, color='black', linestyle='--', linewidth=1.5, alpha=0.6, zorder=1)
    
    # Annotation text
    ax.text(harvest_age + 0.5, 800, 
            'Assumed harvest at age 28\n(Stock change & averaging)',
            fontsize=12, fontweight='bold', verticalalignment='top')
    
    # Labels and titles
    ax.set_xlabel('Forest age (years)', fontsize=14, fontweight='bold')
    ax.set_ylabel('NZU accumulation (t CO₂e/ha)', fontsize=14, fontweight='bold')
    ax.set_title('Carbon accounting under different regimes', fontsize=18, fontweight='bold', pad=15)
    
    ax.legend(loc='upper left', fontsize=16, framealpha=0.9)
    ax.grid(True, alpha=0.3)
    ax.set_xlim(0, max_plot_age)
    ax.set_ylim(0, None)
    
    # Tick adjustments
    ax.tick_params(axis='both', labelsize=12)
    
    plt.tight_layout()
    
    if save_path:
        os.makedirs(os.path.dirname(save_path), exist_ok=True)
        plt.savefig(save_path, dpi=200, bbox_inches='tight')
        print(f"  Accounting comparison plot saved to: {save_path}")
    
    plt.close(fig)


def macro_impact(
    delta_npv_sc_opt: float,
    delta_npv_sc_28: float,
    delta_npv_sc_bank: float,
    new_planting_ha_per_year: float,
    save_path: Optional[str] = None
):
    """
    Plot bar chart of national impact of regime choice relative to averaging.
    """
    avg_value_per_ha = 27977
    
    scenarios = [
        "Stock change\n(bank credits)",
        "Stock change\n(age 28 harvest)",
        "Stock change\n(optimal harvest)"
    ]
    per_ha_values = [delta_npv_sc_bank, delta_npv_sc_28, delta_npv_sc_opt]
    impacts = [v * new_planting_ha_per_year for v in per_ha_values]
    colors = ['#633a01', '#27ae60', '#8e44ad']

    fig, ax = plt.subplots(figsize=(12, 7))

    bars = ax.bar(scenarios, impacts, color=colors, edgecolor='black', alpha=0.8)

    # Add labels on top of bars
    for i, bar in enumerate(bars):
        height = bar.get_height()
        per_ha = per_ha_values[i]
        pct = (per_ha / avg_value_per_ha) * 100
        
        # Total impact label (e.g., $100.5M)
        total_label = f'${height/1e6:.1f}M' if abs(height) >= 1e6 else f'${height:,.0f}'
        # Percentage label (e.g., +5.2%)
        pct_label = f'({pct:+.1f}%)'
        
        full_label = f'{total_label}\n{pct_label}'
        
        # Position inside the bar
        va = 'top' if height >= 0 else 'bottom'
        offset = -8 if height >= 0 else 8
        
        ax.annotate(full_label,
                    xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, offset),
                    textcoords="offset points",
                    ha='center', va=va, fontweight='bold', fontsize=12,
                    color='white')

    ax.axhline(0, color='black', linewidth=0.8, alpha=0.5)
    
    ax.set_title("National impact of regime choice for annual new planting", 
                 fontsize=18, fontweight='bold', pad=20)
    ax.set_ylabel("Change in PV at establishment relative to averaging ($)", 
                  fontsize=14, fontweight='bold')
    
    # Tick adjustments
    ax.tick_params(axis='both', labelsize=12)
    
    # Grid
    ax.grid(True, axis='y', alpha=0.3)
    
    # Format y-axis with commas
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

    plt.tight_layout()

    if save_path:
        os.makedirs(os.path.dirname(save_path), exist_ok=True)
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Macro impact plot saved to: {save_path}")
    
    plt.close(fig)


def plot_value_function(
    V: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot value function by age for different price states.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Plot for regime=0, rotation=1, varying carbon price
    mid_pt = params.N_pt // 2
    colors = plt.cm.viridis(np.linspace(0, 1, params.N_pc))
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for i_pc in range(params.N_pc):
        values_by_age = []
        for a in range(plot_ages):
            state_tuple = (a, i_pc, mid_pt, 0, 1)
            s = state_space.tuple_to_state[state_tuple]
            values_by_age.append(V[s])
        
        ax.plot(range(plot_ages), values_by_age, 
                color=colors[i_pc], 
                label=f'P_c = ${pc_grid[i_pc]:.0f}',
                linewidth=2)
    
    ax.set_xlabel('Stand age (years)', fontsize=12)
    ax.set_ylabel('Value ($)', fontsize=12)
    ax.set_title('Value function by age\n(averaging regime, first rotation, median timber price)',
                 fontsize=13, fontweight='bold')
    ax.legend(title='Carbon Price', loc='upper left')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"\nPlot saved to: {save_path}")
    

def main():
    parser = argparse.ArgumentParser(description="Generate plots for Harvest Timing Model")
    parser.add_argument('--temp-dir', type=str, default='baseline',
                        help='Directory containing the pickle file (default: baseline)')
    parser.add_argument('--pickle-path', type=str, default=None,
                        help='Full path to the pickle file (overrides --temp-dir)')
    parser.add_argument('--output-dir', type=str, default='plots',
                        help='Directory to save plots')
    args = parser.parse_args()
    
    # Determine pickle path
    if args.pickle_path is None:
        pickle_path = os.path.join('outputs', args.temp_dir, 'model_results.pkl')
    else:
        pickle_path = args.pickle_path
    
    if not os.path.exists(pickle_path):
        print(f"Error: Pickle file not found at {pickle_path}")
        print("Run harvest_timing_model.py first to generate results.")
        return

    print(f"Loading results from {pickle_path}...")
    with open(pickle_path, 'rb') as f:
        results = pickle.load(f)
    
    params = results['params']
    state_space = results['state_space']
    price_data = results['price_data']
    V = results['V']
    sigma = results['sigma']
    sim_data = results.get('sim_data')  # May not exist
    
    print("\n--- Generating Visualizations ---")
    
    # Ensure plots directory exists
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Rebuild R and Q matrices needed for simulation
    print("\n--- Rebuilding Reward and Transition Matrices ---")
    C_age = compute_carbon_curve(params)
    V_age = compute_volume_from_carbon(C_age, params)
    DeltaC_avg = compute_carbon_flows_averaging(C_age, params)
    DeltaC_perm = compute_carbon_flows_permanent(C_age)
    price_quality_factor = compute_price_quality_factor(params)
    
    R = build_reward_matrix(params, state_space, price_data, V_age, C_age, DeltaC_avg, DeltaC_perm, price_quality_factor)
    Q_sa, _, _ = build_transition_matrix(params, state_space, price_data)
    print("  ✓ Matrices rebuilt")
    
    # Price paths
    plot_price_paths(params, n_paths=1000, n_periods=51, 
                    save_path=os.path.join(args.output_dir, 'price_paths.png'))
    
    # Accounting comparison (new)
    print("\n--- Generating Accounting Comparison Plot ---")
    plot_accounting_comparison(
        excel_path='data/growth_curves.xlsx',
        params=params,
        save_path=os.path.join(args.output_dir, 'accounting_comparison.png')
    )
    
    # Generate all 9 decision plots (3 states × 3 plot types)
    # generate_all_decision_plots(
    #     sigma, state_space, params, price_data,
    #     max_age_plot=50,
    #     output_dir=args.output_dir
    # )
    
    # # Value function plot
    # plot_value_function(V, state_space, params, price_data,
    #                    max_age_plot=50,
    #                    save_path=os.path.join(args.output_dir, 'value_function.png'))
                       
    # Simulation Trajectory
    print("\n--- Generating Simulation Trajectory ---")
    C_age = compute_carbon_curve(params)
    
    # print("  Simulating trajectory...")
    # for i in range(10):
    #     sim_data = simulate_single_trajectory(
    #         params, state_space, price_data, R, Q, V, sigma, C_age,
    #         n_years=50, seed=42+i
    #     )
    #     plot_simulation_trajectory(sim_data, params, 
    #                             save_path=os.path.join(args.output_dir, f'simulation_trajectory_{i}.png'))
    
    # Conference figures: 2-panel (prices + utilities) for each regime
    print("\n--- Generating Conference Figures ---")
    
    # Generate shared price paths to use for both regimes
    n_conference_years = 50
    conference_seed = 126
    
    carbon_prices_shared = simulate_price_paths(
        params.pc_mean, params.pc_rho, params.pc_sigma,
        n_paths=1, n_periods=n_conference_years + 1, 
        seed=conference_seed, p0=params.pc_0
    ).flatten()
    
    timber_prices_shared = simulate_price_paths(
        params.pt_mean, params.pt_rho, params.pt_sigma,
        n_paths=1, n_periods=n_conference_years + 1, 
        seed=conference_seed + 1
    ).flatten()
    
    # Regime 0: Averaging
    print("  Simulating Averaging regime (regime=0)...")
    sim_data_averaging = simulate_single_trajectory(
        params, state_space, price_data, R, Q_sa, V, sigma, C_age,
        n_years=n_conference_years,
        seed=conference_seed,
        carbon_prices=carbon_prices_shared.copy(),
        timber_prices=timber_prices_shared.copy(),
        initial_age=1,
        initial_regime=0,
        initial_rotation=1
    )
    plot_trajectory_conference(
        sim_data_averaging, params,
        regime_label='averaging accounting',
        save_path=os.path.join(args.output_dir, 'conference_averaging.png')
    )
    plot_trajectory_revenue_conference(
        sim_data_averaging, params,
        regime_label='averaging accounting',
        save_path=os.path.join(args.output_dir, 'conference_averaging_revenue.png')
    )
    
    # Regime 2: Stock-change (Permanent, no penalty)
    print("  Simulating Stock-change regime (regime=2)...")
    sim_data_stockchange = simulate_single_trajectory(
        params, state_space, price_data, R, Q_sa, V, sigma, C_age,
        n_years=n_conference_years,
        seed=conference_seed,
        carbon_prices=carbon_prices_shared.copy(),
        timber_prices=timber_prices_shared.copy(),
        initial_age=1,
        initial_regime=2,
        initial_rotation=1
    )
    plot_trajectory_conference(
        sim_data_stockchange, params,
        regime_label='Stock-change Accounting',
        save_path=os.path.join(args.output_dir, 'conference_stockchange.png')
    )
    plot_trajectory_revenue_conference(
        sim_data_stockchange, params,
        regime_label='Stock-change Accounting',
        save_path=os.path.join(args.output_dir, 'conference_stockchange_revenue.png')
    )
    
    macro_impact(
        delta_npv_sc_opt=5141,
        delta_npv_sc_28=-2481,
        delta_npv_sc_bank=-6653,
        new_planting_ha_per_year=53400,
        save_path='plots/macro_impact.png'
    )

    print("\nAll plots generated successfully.")

if __name__ == "__main__":
    main()

