"""
Plotting script for Harvest Timing Model.

Loads results from pickle file generated by harvest_timing_model.py and generates plots.
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import pickle
import argparse
from typing import Dict, Tuple, Optional

# Import definitions from main model
from harvest_timing_model import (
    ModelParameters, 
    StateSpace, 
    simulate_price_paths,
    simulate_single_trajectory,
    compute_carbon_curve,
    compute_volume_from_carbon,
    compute_carbon_flows_averaging,
    compute_carbon_flows_permanent,
    compute_price_quality_factor,
    build_reward_matrix,
    build_transition_matrix,
    ACTION_DO_NOTHING,
    ACTION_HARVEST_REPLANT,
    ACTION_SWITCH_PERMANENT
)

def plot_price_paths(
    params: ModelParameters,
    n_paths: int = 1000,
    n_periods: int = 100,
    save_path: Optional[str] = None
):
    """
    Plot simulated price paths for carbon and timber prices.
    
    Shows the stochastic nature of the AR(1) price processes.
    """
    # Simulate paths
    carbon_paths = simulate_price_paths(
        params.pc_mean, params.pc_rho, params.pc_sigma,
        n_paths=n_paths, n_periods=n_periods, seed=42, p0=params.pc_0
    )
    timber_paths = simulate_price_paths(
        params.pt_mean, params.pt_rho, params.pt_sigma,
        n_paths=n_paths, n_periods=n_periods, seed=123
    )
    
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    years = np.arange(n_periods)
    
    # --- Carbon price paths ---
    ax = axes[0]
    
    # Plot individual paths with transparency
    for i in range(n_paths):
        ax.plot(years, carbon_paths[i, :], color='#3498db', alpha=0.03, linewidth=0.5)
    
    # Plot percentiles
    p5 = np.percentile(carbon_paths, 5, axis=0)
    p25 = np.percentile(carbon_paths, 25, axis=0)
    p50 = np.percentile(carbon_paths, 50, axis=0)
    p75 = np.percentile(carbon_paths, 75, axis=0)
    p95 = np.percentile(carbon_paths, 95, axis=0)
    
    ax.fill_between(years, p5, p95, alpha=0.2, color='#3498db', label='5th-95th percentile')
    ax.fill_between(years, p25, p75, alpha=0.3, color='#3498db', label='25th-75th percentile')
    ax.plot(years, p50, color='#2c3e50', linewidth=2, label='Median')
    ax.axhline(params.pc_mean, color='#e74c3c', linestyle='--', linewidth=1.5, label=f'Mean = ${params.pc_mean:.0f}')
    
    ax.set_xlabel('Year', fontsize=11)
    ax.set_ylabel('Carbon Price ($/tCO₂)', fontsize=11)
    ax.set_title(f'Carbon Price Paths (n={n_paths})\nρ={params.pc_rho}, σ={params.pc_sigma}', 
                 fontsize=12, fontweight='bold')
    ax.legend(loc='upper right', fontsize=9)
    ax.set_xlim(0, n_periods - 1)
    ax.set_ylim(0, None)
    ax.grid(True, alpha=0.3)
    
    # --- Timber price paths ---
    ax = axes[1]
    
    # Plot individual paths with transparency
    for i in range(n_paths):
        ax.plot(years, timber_paths[i, :], color='#27ae60', alpha=0.03, linewidth=0.5)
    
    # Plot percentiles
    p5 = np.percentile(timber_paths, 5, axis=0)
    p25 = np.percentile(timber_paths, 25, axis=0)
    p50 = np.percentile(timber_paths, 50, axis=0)
    p75 = np.percentile(timber_paths, 75, axis=0)
    p95 = np.percentile(timber_paths, 95, axis=0)
    
    ax.fill_between(years, p5, p95, alpha=0.2, color='#27ae60', label='5th-95th percentile')
    ax.fill_between(years, p25, p75, alpha=0.3, color='#27ae60', label='25th-75th percentile')
    ax.plot(years, p50, color='#2c3e50', linewidth=2, label='Median')
    ax.axhline(params.pt_mean, color='#e74c3c', linestyle='--', linewidth=1.5, label=f'Mean = ${params.pt_mean:.0f}')
    
    ax.set_xlabel('Year', fontsize=11)
    ax.set_ylabel('Timber Price ($/m³)', fontsize=11)
    ax.set_title(f'Timber Price Paths (n={n_paths})\nρ={params.pt_rho}, σ={params.pt_sigma}', 
                 fontsize=12, fontweight='bold')
    ax.legend(loc='upper right', fontsize=9)
    ax.set_xlim(0, n_periods - 1)
    ax.set_ylim(0, None)
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Price paths plot saved to: {save_path}")
    
    # Second figure: just 5 individual paths, no labels, different colors
    fig2, axes2 = plt.subplots(1, 2, figsize=(14, 5))
    
    # Define distinct colors for the 5 paths
    colors = ['#3498db', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c']
    
    # --- Carbon price paths (5 lines) ---
    ax2 = axes2[0]
    for i in range(5):
        ax2.plot(years, carbon_paths[i, :], color=colors[i], alpha=0.8, linewidth=1.5)
    
    ax2.set_xlabel('Year', fontsize=11)
    ax2.set_ylabel('Carbon Price ($/tCO₂)', fontsize=11)
    ax2.set_title(f'Carbon Price Paths (5 samples)\nρ={params.pc_rho}, σ={params.pc_sigma}', 
                 fontsize=12, fontweight='bold')
    ax2.set_xlim(0, 20)#n_periods - 1)
    ax2.set_ylim(0, None)
    ax2.grid(True, alpha=0.3)
    
    # --- Timber price paths (5 lines) ---
    ax2 = axes2[1]
    for i in range(5):
        ax2.plot(years, timber_paths[i, :], color=colors[i], alpha=0.8, linewidth=1.5)
    
    ax2.set_xlabel('Year', fontsize=11)
    ax2.set_ylabel('Timber Price ($/m³)', fontsize=11)
    ax2.set_title(f'Timber Price Paths (5 samples)\nρ={params.pt_rho}, σ={params.pt_sigma}', 
                 fontsize=12, fontweight='bold')
    ax2.set_xlim(0, 20)#n_periods - 1)
    ax2.set_ylim(0, None)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Save to plots directory if provided, or construct name
    if save_path:
        # Assuming save_path is something like 'plots/price_paths.png'
        # We want 'plots/price_paths_10_samples.png'
        dir_name = os.path.dirname(save_path)
        base_name = os.path.basename(save_path)
        name_part = os.path.splitext(base_name)[0]
        ext_part = os.path.splitext(base_name)[1]
        
        sample_path = os.path.join(dir_name, f"{name_part}_10_samples{ext_part}")
        plt.savefig(sample_path, dpi=150, bbox_inches='tight')


def plot_decisions_by_price_state(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    ages: Tuple[int, int, int, int] = (10, 16, 25, 35),
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (timber price, carbon price) space
    for a specific regime/rotation at 4 different ages.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    for ax_idx, age in enumerate(ages):
        ax = axes.flatten()[ax_idx]
        
        # Clamp age to valid range
        a = min(age, params.N_a - 1)
        
        # Build decision matrix (timber price x carbon price)
        decision_matrix = np.zeros((params.N_pt, params.N_pc))
        
        for i_pt in range(params.N_pt):
            for i_pc in range(params.N_pc):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[i_pt, i_pc] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[pt_grid[0], pt_grid[-1], pc_grid[0], pc_grid[-1]]
        )
        
        ax.set_xlabel('Timber Price ($/m³)', fontsize=11)
        ax.set_ylabel('Carbon Price ($/tCO₂)', fontsize=11)
        ax.set_title(f'Age {age}', fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal Decisions by Price State\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def plot_decisions_timber_vs_age(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (age, timber price) space
    at 4 different carbon price levels.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    # Select 4 carbon price indices: very low, medium-low, medium-high, very high
    n_pc = params.N_pc
    pc_indices = [0, n_pc // 3, 2 * n_pc // 3, n_pc - 1]
    pc_labels = ['Very Low', 'Medium-Low', 'Medium-High', 'Very High']
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for ax_idx, (i_pc, pc_label) in enumerate(zip(pc_indices, pc_labels)):
        ax = axes.flatten()[ax_idx]
        
        # Build decision matrix (age x timber price)
        decision_matrix = np.zeros((plot_ages, params.N_pt))
        
        for a in range(plot_ages):
            for i_pt in range(params.N_pt):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[a, i_pt] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[0, plot_ages - 1, pt_grid[0], pt_grid[-1]]
        )
        
        ax.set_xlabel('Stand Age (years)', fontsize=11)
        ax.set_ylabel('Timber Price ($/m³)', fontsize=11)
        ax.set_title(f'{pc_label} Carbon Price (${pc_grid[i_pc]:.0f}/tCO₂)', 
                     fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal Decisions: Timber Price vs Age\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def plot_decisions_carbon_vs_age(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    regime: int,
    rotation: int,
    state_label: str,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot harvest/switch decision regions in (age, carbon price) space
    at 4 different timber price levels.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # Colors for actions
    cmap = plt.cm.colors.ListedColormap(['#2ecc71', '#e74c3c', '#3498db'])
    
    # Select 4 timber price indices: very low, medium-low, medium-high, very high
    n_pt = params.N_pt
    pt_indices = [0, n_pt // 3, 2 * n_pt // 3, n_pt - 1]
    pt_labels = ['Very Low', 'Medium-Low', 'Medium-High', 'Very High']
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for ax_idx, (i_pt, pt_label) in enumerate(zip(pt_indices, pt_labels)):
        ax = axes.flatten()[ax_idx]
        
        # Build decision matrix (age x carbon price)
        decision_matrix = np.zeros((plot_ages, params.N_pc))
        
        for a in range(plot_ages):
            for i_pc in range(params.N_pc):
                state_tuple = (a, i_pc, i_pt, regime, rotation)
                s = state_space.tuple_to_state[state_tuple]
                decision_matrix[a, i_pc] = sigma[s]
        
        # Plot
        im = ax.imshow(
            decision_matrix.T,
            aspect='auto',
            origin='lower',
            cmap=cmap,
            vmin=0,
            vmax=2,
            extent=[0, plot_ages - 1, pc_grid[0], pc_grid[-1]]
        )
        
        ax.set_xlabel('Stand Age (years)', fontsize=11)
        ax.set_ylabel('Carbon Price ($/tCO₂)', fontsize=11)
        ax.set_title(f'{pt_label} Timber Price (${pt_grid[i_pt]:.0f}/m³)', 
                     fontsize=12, fontweight='bold')
    
    # Add colorbar
    cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
    cbar = fig.colorbar(im, cax=cbar_ax, ticks=[0.33, 1, 1.67])
    cbar.ax.set_yticklabels(['Hold', 'Harvest', 'Switch'])
    
    plt.suptitle(f'Optimal Decisions: Carbon Price vs Age\n{state_label}', 
                 fontsize=14, fontweight='bold', y=1.02)
    plt.tight_layout(rect=[0, 0, 0.9, 1])
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"  Saved: {save_path}")
    
    plt.close(fig)


def generate_all_decision_plots(
    sigma: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    max_age_plot: int = 50,
    output_dir: str = 'plots'
):
    """
    Generate all 9 decision region plots (3 states × 3 plot types).
    """
    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)
    
    # Define the 3 states to plot
    states = [
        (0, 1, 'averaging_1st', 'Averaging 1st Rotation'),
        (0, 2, 'averaging_2plus', 'Averaging 2+ Rotation'),
        (1, 1, 'permanent', 'Permanent'),  # rotation doesn't matter for permanent
    ]
    
    for regime, rotation, file_prefix, state_label in states:
        print(f"\n  Generating plots for {state_label}...")
        
        # 1. Price vs price at ages 10, 16, 25, 35
        plot_decisions_by_price_state(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            ages=(10, 16, 25, 35),
            save_path=os.path.join(output_dir, f'{file_prefix}_price_vs_price.png')
        )
        
        # 2. Timber price vs age at fixed carbon prices
        plot_decisions_timber_vs_age(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            max_age_plot=max_age_plot,
            save_path=os.path.join(output_dir, f'{file_prefix}_timber_vs_age.png')
        )
        
        # 3. Carbon price vs age at fixed timber prices
        plot_decisions_carbon_vs_age(
            sigma, state_space, params, price_data,
            regime=regime, rotation=rotation,
            state_label=state_label,
            max_age_plot=max_age_plot,
            save_path=os.path.join(output_dir, f'{file_prefix}_carbon_vs_age.png')
        )


def plot_simulation_trajectory(
    data: Dict,
    params: ModelParameters,
    save_path: str = 'plots/simulation_trajectory.png'
):
    """
    Plot the simulated trajectory (4 panels).
    """
    years = data['years']
    n_years = len(years)
    
    fig, axes = plt.subplots(4, 1, figsize=(12, 16), sharex=True)
    
    # --- Panel 1: Price Trajectories ---
    ax = axes[0]
    ax.plot(years, data['carbon_price'], color='#3498db', linewidth=2, label='Carbon Price ($/tCO₂)')
    ax.plot(years, data['timber_price'], color='#27ae60', linewidth=2, label='Timber Price ($/m³)')
    ax.set_ylabel('Price', fontsize=12)
    ax.set_title('Simulated Price Trajectories', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3)
    
    # --- Panel 2: Utilities (Q-values) ---
    ax = axes[1]
    ax.plot(years, data['q_hold'], color='#95a5a6', linestyle='-', linewidth=1.5, label='Hold Value')
    ax.plot(years, data['q_harvest'], color='#e74c3c', linestyle='--', linewidth=1.5, label='Harvest Value')
    ax.plot(years, data['q_switch'], color='#8e44ad', linestyle=':', linewidth=1.5, label='Switch Value')
    
    # Annotate actions
    # Plot markers where action is NOT Hold
    harvest_indices = np.where(data['action'] == ACTION_HARVEST_REPLANT)[0]
    switch_indices = np.where(data['action'] == ACTION_SWITCH_PERMANENT)[0]
    
    if len(harvest_indices) > 0:
        ax.scatter(years[harvest_indices], data['q_harvest'][harvest_indices], 
                   color='red', s=100, zorder=10, label='Harvest Action')
        for idx in harvest_indices:
            ax.annotate('Harvest', (years[idx], data['q_harvest'][idx]), 
                        xytext=(0, 15), textcoords='offset points', ha='center', color='red', fontweight='bold')
            
    if len(switch_indices) > 0:
        # Only mark the *first* switch if multiple (since switch is permanent state change)
        # But technically action 2 can be chosen repeatedly (though effect is idempotent)
        # We'll mark all just in case
        ax.scatter(years[switch_indices], data['q_switch'][switch_indices], 
                   color='purple', s=100, zorder=10, marker='s', label='Switch Action')
        for idx in switch_indices:
            # only annotate if it's a regime change
            if idx > 0 and data['regime'][idx] == 1 and data['regime'][idx-1] == 0:
                 ax.annotate('Switch', (years[idx], data['q_switch'][idx]), 
                            xytext=(0, 15), textcoords='offset points', ha='center', color='purple', fontweight='bold')
    
    ax.set_ylabel('Total Utility ($/ha)', fontsize=12)
    ax.set_title('Option Utilities (Immediate + Continuation)', fontsize=14, fontweight='bold')
    ax.legend(loc='upper left')
    ax.grid(True, alpha=0.3)
    
    # --- Panel 3: Net Revenue ---
    ax = axes[2]
    # Plot as bar chart? Or line with markers?
    # Most years are small negative (maintenance cost) or positive (carbon credits)
    # Harvest years are huge positive spikes.
    # Switch year might be negative spike (penalty).
    
    # Separate positive and negative for color
    pos_mask = data['net_revenue'] >= 0
    neg_mask = data['net_revenue'] < 0
    
    ax.bar(years[pos_mask], data['net_revenue'][pos_mask], color='#2ecc71', alpha=0.7, label='Net Revenue (>0)')
    ax.bar(years[neg_mask], data['net_revenue'][neg_mask], color='#e74c3c', alpha=0.7, label='Net Revenue (<0)')
    
    ax.axhline(0, color='black', linewidth=0.5)
    ax.set_ylabel('Net Revenue ($/ha)', fontsize=12)
    ax.set_title('Realized Net Revenue', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3, axis='y')
    
    # --- Panel 4: Carbon Stock ---
    ax = axes[3]
    
    # Plot carbon stock
    # Color differently based on regime
    regime_0_mask = data['regime'] == 0
    regime_1_mask = data['regime'] == 1
    regime_2_mask = data['regime'] == 2
    
    # We can't easily use mask for line plot connectivity. 
    # Just plot entire line, then overlay?
    ax.plot(years, data['carbon_stock'], color='black', linewidth=1, alpha=0.3)
    
    # Plot segments
    # Simple way: scatter points
    ax.scatter(years[regime_0_mask], data['carbon_stock'][regime_0_mask], 
               color='#f1c40f', s=20, label='Averaging Regime')
    ax.scatter(years[regime_1_mask], data['carbon_stock'][regime_1_mask], 
               color='#8e44ad', s=20, label='Permanent Regime')
    ax.scatter(years[regime_2_mask], data['carbon_stock'][regime_2_mask], 
               color='#27ae60', s=20, label='Permanent (No Penalty)')

    ax.set_ylabel('Carbon Stock (tCO₂/ha)', fontsize=12)
    ax.set_title('Forest Carbon Stock', fontsize=14, fontweight='bold')
    ax.set_xlabel('Simulation Year', fontsize=12)
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"\nTrajectory simulation saved to: {save_path}")
    

def plot_value_function(
    V: np.ndarray,
    state_space: StateSpace,
    params: ModelParameters,
    price_data: Dict,
    max_age_plot: int = 50,
    save_path: Optional[str] = None
):
    """
    Plot value function by age for different price states.
    """
    pc_grid = price_data['pc_grid']
    pt_grid = price_data['pt_grid']
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Plot for regime=0, rotation=1, varying carbon price
    mid_pt = params.N_pt // 2
    colors = plt.cm.viridis(np.linspace(0, 1, params.N_pc))
    
    plot_ages = min(max_age_plot + 1, params.N_a)
    
    for i_pc in range(params.N_pc):
        values_by_age = []
        for a in range(plot_ages):
            state_tuple = (a, i_pc, mid_pt, 0, 1)
            s = state_space.tuple_to_state[state_tuple]
            values_by_age.append(V[s])
        
        ax.plot(range(plot_ages), values_by_age, 
                color=colors[i_pc], 
                label=f'P_c = ${pc_grid[i_pc]:.0f}',
                linewidth=2)
    
    ax.set_xlabel('Stand Age (years)', fontsize=12)
    ax.set_ylabel('Value ($)', fontsize=12)
    ax.set_title('Value Function by Age\n(Averaging Regime, First Rotation, Median Timber Price)',
                 fontsize=13, fontweight='bold')
    ax.legend(title='Carbon Price', loc='upper left')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"\nPlot saved to: {save_path}")
    

def main():
    parser = argparse.ArgumentParser(description="Generate plots for Harvest Timing Model")
    parser.add_argument('--temp-dir', type=str, default='temp',
                        help='Directory containing the pickle file (default: temp)')
    parser.add_argument('--pickle-path', type=str, default=None,
                        help='Full path to the pickle file (overrides --temp-dir)')
    parser.add_argument('--output-dir', type=str, default='plots',
                        help='Directory to save plots')
    args = parser.parse_args()
    
    # Determine pickle path
    if args.pickle_path is None:
        pickle_path = os.path.join('outputs', args.temp_dir, 'model_results.pkl')
    else:
        pickle_path = args.pickle_path
    
    if not os.path.exists(pickle_path):
        print(f"Error: Pickle file not found at {pickle_path}")
        print("Run harvest_timing_model.py first to generate results.")
        return

    print(f"Loading results from {pickle_path}...")
    with open(pickle_path, 'rb') as f:
        results = pickle.load(f)
    
    params = results['params']
    state_space = results['state_space']
    price_data = results['price_data']
    V = results['V']
    sigma = results['sigma']
    sim_data = results.get('sim_data')  # May not exist
    
    print("\n--- Generating Visualizations ---")
    
    # Ensure plots directory exists
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Rebuild R and Q matrices needed for simulation
    print("\n--- Rebuilding Reward and Transition Matrices ---")
    C_age = compute_carbon_curve(params)
    V_age = compute_volume_from_carbon(C_age, params)
    DeltaC_avg = compute_carbon_flows_averaging(C_age, params)
    DeltaC_perm = compute_carbon_flows_permanent(C_age)
    price_quality_factor = compute_price_quality_factor(params)
    
    R = build_reward_matrix(params, state_space, price_data, V_age, C_age, DeltaC_avg, DeltaC_perm, price_quality_factor)
    Q = build_transition_matrix(params, state_space, price_data)
    print("  ✓ Matrices rebuilt")
    
    # Price paths
    plot_price_paths(params, n_paths=1000, n_periods=100, 
                    save_path=os.path.join(args.output_dir, 'price_paths.png'))
    
    # Generate all 9 decision plots (3 states × 3 plot types)
    generate_all_decision_plots(
        sigma, state_space, params, price_data,
        max_age_plot=50,
        output_dir=args.output_dir
    )
    
    # Value function plot
    plot_value_function(V, state_space, params, price_data,
                       max_age_plot=50,
                       save_path=os.path.join(args.output_dir, 'value_function.png'))
                       
    # Simulation Trajectory
    print("\n--- Generating Simulation Trajectory ---")
    C_age = compute_carbon_curve(params)
    
    print("  Simulating trajectory...")
    for i in range(10):
        sim_data = simulate_single_trajectory(
            params, state_space, price_data, R, Q, V, sigma, C_age,
            n_years=50, seed=42+i
        )
        plot_simulation_trajectory(sim_data, params, 
                                save_path=os.path.join(args.output_dir, f'simulation_trajectory_{i}.png'))
    
    print("\nAll plots generated successfully.")

if __name__ == "__main__":
    main()

